// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../../../BaseClient";
import * as core from "../../../../../../../../core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../../../core/headers";
import * as environments from "../../../../../../../../environments";
import * as serializers from "../../../../../../../../serialization/index";
import * as CandidApi from "../../../../../../../index";

export declare namespace V1 {
    export interface Options extends BaseClientOptions {
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    export interface RequestOptions extends BaseRequestOptions {}
}

export class V1 {
    protected readonly _options: V1.Options;

    constructor(_options: V1.Options = {}) {
        this._options = _options;
    }

    /**
     * Adds a patient.  VersionConflictError is returned when the patient's external ID is already in use.
     *
     * @param {CandidApi.preEncounter.patients.v1.CreatePatientRequest} request
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.create({
     *         body: {
     *             name: {
     *                 family: "family",
     *                 given: ["given", "given"],
     *                 use: "USUAL"
     *             },
     *             otherNames: [{
     *                     family: "family",
     *                     given: ["given", "given"],
     *                     use: "USUAL"
     *                 }, {
     *                     family: "family",
     *                     given: ["given", "given"],
     *                     use: "USUAL"
     *                 }],
     *             birthDate: "2023-01-15",
     *             biologicalSex: "FEMALE",
     *             primaryAddress: {
     *                 use: "HOME",
     *                 line: ["line", "line"],
     *                 city: "city",
     *                 state: "state",
     *                 postalCode: "postal_code",
     *                 country: "country"
     *             },
     *             otherAddresses: [{
     *                     use: "HOME",
     *                     line: ["line", "line"],
     *                     city: "city",
     *                     state: "state",
     *                     postalCode: "postal_code",
     *                     country: "country"
     *                 }, {
     *                     use: "HOME",
     *                     line: ["line", "line"],
     *                     city: "city",
     *                     state: "state",
     *                     postalCode: "postal_code",
     *                     country: "country"
     *                 }],
     *             otherTelecoms: [{
     *                     value: "value",
     *                     use: "HOME"
     *                 }, {
     *                     value: "value",
     *                     use: "HOME"
     *                 }],
     *             contacts: [{
     *                     relationship: ["SELF", "SELF"],
     *                     name: {
     *                         family: "family",
     *                         given: ["given", "given"],
     *                         use: "USUAL"
     *                     },
     *                     telecoms: [{
     *                             value: "value",
     *                             use: "HOME"
     *                         }, {
     *                             value: "value",
     *                             use: "HOME"
     *                         }],
     *                     addresses: [{
     *                             use: "HOME",
     *                             line: ["line", "line"],
     *                             city: "city",
     *                             state: "state",
     *                             postalCode: "postal_code",
     *                             country: "country"
     *                         }, {
     *                             use: "HOME",
     *                             line: ["line", "line"],
     *                             city: "city",
     *                             state: "state",
     *                             postalCode: "postal_code",
     *                             country: "country"
     *                         }]
     *                 }, {
     *                     relationship: ["SELF", "SELF"],
     *                     name: {
     *                         family: "family",
     *                         given: ["given", "given"],
     *                         use: "USUAL"
     *                     },
     *                     telecoms: [{
     *                             value: "value",
     *                             use: "HOME"
     *                         }, {
     *                             value: "value",
     *                             use: "HOME"
     *                         }],
     *                     addresses: [{
     *                             use: "HOME",
     *                             line: ["line", "line"],
     *                             city: "city",
     *                             state: "state",
     *                             postalCode: "postal_code",
     *                             country: "country"
     *                         }, {
     *                             use: "HOME",
     *                             line: ["line", "line"],
     *                             city: "city",
     *                             state: "state",
     *                             postalCode: "postal_code",
     *                             country: "country"
     *                         }]
     *                 }],
     *             generalPractitioners: [{
     *                     name: {
     *                         family: "family",
     *                         given: ["given", "given"],
     *                         use: "USUAL"
     *                     },
     *                     telecoms: [{
     *                             value: "value",
     *                             use: "HOME"
     *                         }, {
     *                             value: "value",
     *                             use: "HOME"
     *                         }]
     *                 }, {
     *                     name: {
     *                         family: "family",
     *                         given: ["given", "given"],
     *                         use: "USUAL"
     *                     },
     *                     telecoms: [{
     *                             value: "value",
     *                             use: "HOME"
     *                         }, {
     *                             value: "value",
     *                             use: "HOME"
     *                         }]
     *                 }],
     *             filingOrder: {
     *                 coverages: [CandidApi.preEncounter.CoverageId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"), CandidApi.preEncounter.CoverageId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32")]
     *             }
     *         }
     *     })
     */
    public create(
        request: CandidApi.preEncounter.patients.v1.CreatePatientRequest,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.preEncounter.patients.v1.Patient, CandidApi.preEncounter.patients.v1.create.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: CandidApi.preEncounter.patients.v1.CreatePatientRequest,
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.patients.v1.Patient,
                CandidApi.preEncounter.patients.v1.create.Error
            >
        >
    > {
        const { skipDuplicateCheck, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (skipDuplicateCheck != null) {
            _queryParams.skip_duplicate_check = skipDuplicateCheck.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                "/patients/v1",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: serializers.preEncounter.patients.v1.MutablePatient.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.Patient.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.preEncounter.patients.v1.create.Error.Raw)?.errorName) {
                case "VersionConflictError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.preEncounter.patients.v1.create.Error.parseOrThrow(
                                _response.error.body as serializers.preEncounter.patients.v1.create.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.create.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Adds a patient and hydrates their MRN with a pre-existing MRN.  Once this patient is created their MRN will not be editable. BadRequestError is returned when the MRN is greater than 20 characters. VersionConflictError is returned when the patient's external ID is already in use.
     *
     * @param {CandidApi.preEncounter.patients.v1.CreatePatientWithMrnRequest} request
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.createWithMrn({
     *         body: {
     *             mrn: "mrn",
     *             name: {
     *                 family: "family",
     *                 given: ["given", "given"],
     *                 use: "USUAL"
     *             },
     *             otherNames: [{
     *                     family: "family",
     *                     given: ["given", "given"],
     *                     use: "USUAL"
     *                 }, {
     *                     family: "family",
     *                     given: ["given", "given"],
     *                     use: "USUAL"
     *                 }],
     *             birthDate: "2023-01-15",
     *             biologicalSex: "FEMALE",
     *             primaryAddress: {
     *                 use: "HOME",
     *                 line: ["line", "line"],
     *                 city: "city",
     *                 state: "state",
     *                 postalCode: "postal_code",
     *                 country: "country"
     *             },
     *             otherAddresses: [{
     *                     use: "HOME",
     *                     line: ["line", "line"],
     *                     city: "city",
     *                     state: "state",
     *                     postalCode: "postal_code",
     *                     country: "country"
     *                 }, {
     *                     use: "HOME",
     *                     line: ["line", "line"],
     *                     city: "city",
     *                     state: "state",
     *                     postalCode: "postal_code",
     *                     country: "country"
     *                 }],
     *             otherTelecoms: [{
     *                     value: "value",
     *                     use: "HOME"
     *                 }, {
     *                     value: "value",
     *                     use: "HOME"
     *                 }],
     *             contacts: [{
     *                     relationship: ["SELF", "SELF"],
     *                     name: {
     *                         family: "family",
     *                         given: ["given", "given"],
     *                         use: "USUAL"
     *                     },
     *                     telecoms: [{
     *                             value: "value",
     *                             use: "HOME"
     *                         }, {
     *                             value: "value",
     *                             use: "HOME"
     *                         }],
     *                     addresses: [{
     *                             use: "HOME",
     *                             line: ["line", "line"],
     *                             city: "city",
     *                             state: "state",
     *                             postalCode: "postal_code",
     *                             country: "country"
     *                         }, {
     *                             use: "HOME",
     *                             line: ["line", "line"],
     *                             city: "city",
     *                             state: "state",
     *                             postalCode: "postal_code",
     *                             country: "country"
     *                         }]
     *                 }, {
     *                     relationship: ["SELF", "SELF"],
     *                     name: {
     *                         family: "family",
     *                         given: ["given", "given"],
     *                         use: "USUAL"
     *                     },
     *                     telecoms: [{
     *                             value: "value",
     *                             use: "HOME"
     *                         }, {
     *                             value: "value",
     *                             use: "HOME"
     *                         }],
     *                     addresses: [{
     *                             use: "HOME",
     *                             line: ["line", "line"],
     *                             city: "city",
     *                             state: "state",
     *                             postalCode: "postal_code",
     *                             country: "country"
     *                         }, {
     *                             use: "HOME",
     *                             line: ["line", "line"],
     *                             city: "city",
     *                             state: "state",
     *                             postalCode: "postal_code",
     *                             country: "country"
     *                         }]
     *                 }],
     *             generalPractitioners: [{
     *                     name: {
     *                         family: "family",
     *                         given: ["given", "given"],
     *                         use: "USUAL"
     *                     },
     *                     telecoms: [{
     *                             value: "value",
     *                             use: "HOME"
     *                         }, {
     *                             value: "value",
     *                             use: "HOME"
     *                         }]
     *                 }, {
     *                     name: {
     *                         family: "family",
     *                         given: ["given", "given"],
     *                         use: "USUAL"
     *                     },
     *                     telecoms: [{
     *                             value: "value",
     *                             use: "HOME"
     *                         }, {
     *                             value: "value",
     *                             use: "HOME"
     *                         }]
     *                 }],
     *             filingOrder: {
     *                 coverages: [CandidApi.preEncounter.CoverageId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"), CandidApi.preEncounter.CoverageId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32")]
     *             }
     *         }
     *     })
     */
    public createWithMrn(
        request: CandidApi.preEncounter.patients.v1.CreatePatientWithMrnRequest,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<
            CandidApi.preEncounter.patients.v1.Patient,
            CandidApi.preEncounter.patients.v1.createWithMrn.Error
        >
    > {
        return core.HttpResponsePromise.fromPromise(this.__createWithMrn(request, requestOptions));
    }

    private async __createWithMrn(
        request: CandidApi.preEncounter.patients.v1.CreatePatientWithMrnRequest,
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.patients.v1.Patient,
                CandidApi.preEncounter.patients.v1.createWithMrn.Error
            >
        >
    > {
        const { skipDuplicateCheck, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (skipDuplicateCheck != null) {
            _queryParams.skip_duplicate_check = skipDuplicateCheck.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                "/patients/v1/with_mrn",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: serializers.preEncounter.patients.v1.MutablePatientWithMrn.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.Patient.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.preEncounter.patients.v1.createWithMrn.Error.Raw)?.errorName) {
                case "VersionConflictError":
                case "BadRequestError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.preEncounter.patients.v1.createWithMrn.Error.parseOrThrow(
                                _response.error.body as serializers.preEncounter.patients.v1.createWithMrn.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.createWithMrn.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Searches for patients that match the query parameters.
     *
     * @param {CandidApi.preEncounter.patients.v1.PatientsSearchRequestPaginated} request
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.getMulti()
     */
    public getMulti(
        request: CandidApi.preEncounter.patients.v1.PatientsSearchRequestPaginated = {},
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<
            CandidApi.preEncounter.patients.v1.PatientPage,
            CandidApi.preEncounter.patients.v1.getMulti.Error
        >
    > {
        return core.HttpResponsePromise.fromPromise(this.__getMulti(request, requestOptions));
    }

    private async __getMulti(
        request: CandidApi.preEncounter.patients.v1.PatientsSearchRequestPaginated = {},
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.patients.v1.PatientPage,
                CandidApi.preEncounter.patients.v1.getMulti.Error
            >
        >
    > {
        const { limit, mrn, pageToken, sortField, sortDirection } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (mrn != null) {
            _queryParams.mrn = mrn;
        }

        if (pageToken != null) {
            _queryParams.page_token = pageToken;
        }

        if (sortField != null) {
            _queryParams.sort_field = sortField;
        }

        if (sortDirection != null) {
            _queryParams.sort_direction = serializers.preEncounter.SortDirection.jsonOrThrow(sortDirection, {
                unrecognizedObjectKeys: "strip",
            });
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                "/patients/v1/get_multi",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.PatientPage.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.getMulti.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Searches for referring providers that match the query parameters.  The search is case-insensitive, supports fuzzy matching, and matches against provider name and NPI. The search criteria must be an alphanumeric string, and the search is limited to the first 20 results.
     *
     * @param {CandidApi.preEncounter.patients.v1.SearchProvidersRequest} request
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.searchProviders({
     *         searchCriteria: "search_criteria"
     *     })
     */
    public searchProviders(
        request: CandidApi.preEncounter.patients.v1.SearchProvidersRequest,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<
            CandidApi.preEncounter.ExternalProvider[],
            CandidApi.preEncounter.patients.v1.searchProviders.Error
        >
    > {
        return core.HttpResponsePromise.fromPromise(this.__searchProviders(request, requestOptions));
    }

    private async __searchProviders(
        request: CandidApi.preEncounter.patients.v1.SearchProvidersRequest,
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.ExternalProvider[],
                CandidApi.preEncounter.patients.v1.searchProviders.Error
            >
        >
    > {
        const { searchCriteria } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.search_criteria = searchCriteria;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                "/patients/v1/search_providers",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.searchProviders.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.searchProviders.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Gets a patient.
     *
     * @param {CandidApi.preEncounter.PatientId} id
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.get(CandidApi.preEncounter.PatientId("id"))
     */
    public get(
        id: CandidApi.preEncounter.PatientId,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.preEncounter.patients.v1.Patient, CandidApi.preEncounter.patients.v1.get.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
    }

    private async __get(
        id: CandidApi.preEncounter.PatientId,
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<CandidApi.preEncounter.patients.v1.Patient, CandidApi.preEncounter.patients.v1.get.Error>
        >
    > {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                `/patients/v1/${core.url.encodePathParam(serializers.preEncounter.PatientId.jsonOrThrow(id))}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.Patient.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.preEncounter.patients.v1.get.Error.Raw)?.errorName) {
                case "NotFoundError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.preEncounter.patients.v1.get.Error.parseOrThrow(
                                _response.error.body as serializers.preEncounter.patients.v1.get.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.get.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Gets a patient by mrn.
     *
     * @param {string} mrn
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.getByMrn("mrn")
     */
    public getByMrn(
        mrn: string,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.preEncounter.patients.v1.Patient, CandidApi.preEncounter.patients.v1.getByMrn.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__getByMrn(mrn, requestOptions));
    }

    private async __getByMrn(
        mrn: string,
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.patients.v1.Patient,
                CandidApi.preEncounter.patients.v1.getByMrn.Error
            >
        >
    > {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                `/patients/v1/mrn/${core.url.encodePathParam(mrn)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.Patient.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.preEncounter.patients.v1.getByMrn.Error.Raw)?.errorName) {
                case "NotFoundError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.preEncounter.patients.v1.getByMrn.Error.parseOrThrow(
                                _response.error.body as serializers.preEncounter.patients.v1.getByMrn.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.getByMrn.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Gets a patient along with it's full history.  The return list is ordered by version ascending.
     *
     * @param {CandidApi.preEncounter.PatientId} id
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.getHistory(CandidApi.preEncounter.PatientId("id"))
     */
    public getHistory(
        id: CandidApi.preEncounter.PatientId,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<
            CandidApi.preEncounter.patients.v1.Patient[],
            CandidApi.preEncounter.patients.v1.getHistory.Error
        >
    > {
        return core.HttpResponsePromise.fromPromise(this.__getHistory(id, requestOptions));
    }

    private async __getHistory(
        id: CandidApi.preEncounter.PatientId,
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.patients.v1.Patient[],
                CandidApi.preEncounter.patients.v1.getHistory.Error
            >
        >
    > {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                `/patients/v1/${core.url.encodePathParam(serializers.preEncounter.PatientId.jsonOrThrow(id))}/history`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.getHistory.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.preEncounter.patients.v1.getHistory.Error.Raw)?.errorName) {
                case "NotFoundError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.preEncounter.patients.v1.getHistory.Error.parseOrThrow(
                                _response.error.body as serializers.preEncounter.patients.v1.getHistory.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.getHistory.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Updates a patient. The path must contain the next version number to prevent race conditions. For example, if the current version of the patient is n, you will need to send a request to this endpoint with `/{id}/n+1` to update the patient. Updating historic versions is not supported.
     *
     * @param {CandidApi.preEncounter.PatientId} id
     * @param {string} version
     * @param {CandidApi.preEncounter.patients.v1.MutablePatient} request
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.update(CandidApi.preEncounter.PatientId("id"), "version", {
     *         name: {
     *             family: "family",
     *             given: ["given", "given"],
     *             use: "USUAL"
     *         },
     *         otherNames: [{
     *                 family: "family",
     *                 given: ["given", "given"],
     *                 use: "USUAL"
     *             }, {
     *                 family: "family",
     *                 given: ["given", "given"],
     *                 use: "USUAL"
     *             }],
     *         birthDate: "2023-01-15",
     *         biologicalSex: "FEMALE",
     *         primaryAddress: {
     *             use: "HOME",
     *             line: ["line", "line"],
     *             city: "city",
     *             state: "state",
     *             postalCode: "postal_code",
     *             country: "country"
     *         },
     *         otherAddresses: [{
     *                 use: "HOME",
     *                 line: ["line", "line"],
     *                 city: "city",
     *                 state: "state",
     *                 postalCode: "postal_code",
     *                 country: "country"
     *             }, {
     *                 use: "HOME",
     *                 line: ["line", "line"],
     *                 city: "city",
     *                 state: "state",
     *                 postalCode: "postal_code",
     *                 country: "country"
     *             }],
     *         otherTelecoms: [{
     *                 value: "value",
     *                 use: "HOME"
     *             }, {
     *                 value: "value",
     *                 use: "HOME"
     *             }],
     *         contacts: [{
     *                 relationship: ["SELF", "SELF"],
     *                 name: {
     *                     family: "family",
     *                     given: ["given", "given"],
     *                     use: "USUAL"
     *                 },
     *                 telecoms: [{
     *                         value: "value",
     *                         use: "HOME"
     *                     }, {
     *                         value: "value",
     *                         use: "HOME"
     *                     }],
     *                 addresses: [{
     *                         use: "HOME",
     *                         line: ["line", "line"],
     *                         city: "city",
     *                         state: "state",
     *                         postalCode: "postal_code",
     *                         country: "country"
     *                     }, {
     *                         use: "HOME",
     *                         line: ["line", "line"],
     *                         city: "city",
     *                         state: "state",
     *                         postalCode: "postal_code",
     *                         country: "country"
     *                     }]
     *             }, {
     *                 relationship: ["SELF", "SELF"],
     *                 name: {
     *                     family: "family",
     *                     given: ["given", "given"],
     *                     use: "USUAL"
     *                 },
     *                 telecoms: [{
     *                         value: "value",
     *                         use: "HOME"
     *                     }, {
     *                         value: "value",
     *                         use: "HOME"
     *                     }],
     *                 addresses: [{
     *                         use: "HOME",
     *                         line: ["line", "line"],
     *                         city: "city",
     *                         state: "state",
     *                         postalCode: "postal_code",
     *                         country: "country"
     *                     }, {
     *                         use: "HOME",
     *                         line: ["line", "line"],
     *                         city: "city",
     *                         state: "state",
     *                         postalCode: "postal_code",
     *                         country: "country"
     *                     }]
     *             }],
     *         generalPractitioners: [{
     *                 name: {
     *                     family: "family",
     *                     given: ["given", "given"],
     *                     use: "USUAL"
     *                 },
     *                 telecoms: [{
     *                         value: "value",
     *                         use: "HOME"
     *                     }, {
     *                         value: "value",
     *                         use: "HOME"
     *                     }]
     *             }, {
     *                 name: {
     *                     family: "family",
     *                     given: ["given", "given"],
     *                     use: "USUAL"
     *                 },
     *                 telecoms: [{
     *                         value: "value",
     *                         use: "HOME"
     *                     }, {
     *                         value: "value",
     *                         use: "HOME"
     *                     }]
     *             }],
     *         filingOrder: {
     *             coverages: [CandidApi.preEncounter.CoverageId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"), CandidApi.preEncounter.CoverageId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32")]
     *         }
     *     })
     */
    public update(
        id: CandidApi.preEncounter.PatientId,
        version: string,
        request: CandidApi.preEncounter.patients.v1.MutablePatient,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.preEncounter.patients.v1.Patient, CandidApi.preEncounter.patients.v1.update.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__update(id, version, request, requestOptions));
    }

    private async __update(
        id: CandidApi.preEncounter.PatientId,
        version: string,
        request: CandidApi.preEncounter.patients.v1.MutablePatient,
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.patients.v1.Patient,
                CandidApi.preEncounter.patients.v1.update.Error
            >
        >
    > {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                `/patients/v1/${core.url.encodePathParam(serializers.preEncounter.PatientId.jsonOrThrow(id))}/${core.url.encodePathParam(version)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.preEncounter.patients.v1.MutablePatient.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.Patient.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.preEncounter.patients.v1.update.Error.Raw)?.errorName) {
                case "NotFoundError":
                case "VersionConflictError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.preEncounter.patients.v1.update.Error.parseOrThrow(
                                _response.error.body as serializers.preEncounter.patients.v1.update.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.update.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Sets a patient as deactivated.  The path must contain the most recent version plus 1 to prevent race conditions.  Deactivating historic versions is not supported.
     *
     * @param {CandidApi.preEncounter.PatientId} id
     * @param {string} version
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.deactivate(CandidApi.preEncounter.PatientId("id"), "version")
     */
    public deactivate(
        id: CandidApi.preEncounter.PatientId,
        version: string,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<void, CandidApi.preEncounter.patients.v1.deactivate.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__deactivate(id, version, requestOptions));
    }

    private async __deactivate(
        id: CandidApi.preEncounter.PatientId,
        version: string,
        requestOptions?: V1.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<void, CandidApi.preEncounter.patients.v1.deactivate.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                `/patients/v1/${core.url.encodePathParam(serializers.preEncounter.PatientId.jsonOrThrow(id))}/${core.url.encodePathParam(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: undefined,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.preEncounter.patients.v1.deactivate.Error.Raw)?.errorName) {
                case "NotFoundError":
                case "VersionConflictError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.preEncounter.patients.v1.deactivate.Error.parseOrThrow(
                                _response.error.body as serializers.preEncounter.patients.v1.deactivate.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.deactivate.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Removes the deactivated flag for a patient.  The path must contain the most recent version plus 1 to prevent race conditions.  Reactivating historic versions is not supported.
     *
     * @param {CandidApi.preEncounter.PatientId} id
     * @param {string} version
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.reactivate(CandidApi.preEncounter.PatientId("id"), "version")
     */
    public reactivate(
        id: CandidApi.preEncounter.PatientId,
        version: string,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<void, CandidApi.preEncounter.patients.v1.reactivate.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__reactivate(id, version, requestOptions));
    }

    private async __reactivate(
        id: CandidApi.preEncounter.PatientId,
        version: string,
        requestOptions?: V1.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<void, CandidApi.preEncounter.patients.v1.reactivate.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                `/patients/v1/${core.url.encodePathParam(serializers.preEncounter.PatientId.jsonOrThrow(id))}/${core.url.encodePathParam(version)}`,
            ),
            method: "PATCH",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: undefined,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.preEncounter.patients.v1.reactivate.Error.Raw)?.errorName) {
                case "NotFoundError":
                case "VersionConflictError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.preEncounter.patients.v1.reactivate.Error.parseOrThrow(
                                _response.error.body as serializers.preEncounter.patients.v1.reactivate.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.reactivate.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Returns a list of Patients based on the search criteria.
     *
     * @param {CandidApi.preEncounter.patients.v1.PatientGetMultiRequest} request
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.search()
     */
    public search(
        request: CandidApi.preEncounter.patients.v1.PatientGetMultiRequest = {},
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.preEncounter.patients.v1.Patient[], CandidApi.preEncounter.patients.v1.search.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__search(request, requestOptions));
    }

    private async __search(
        request: CandidApi.preEncounter.patients.v1.PatientGetMultiRequest = {},
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.patients.v1.Patient[],
                CandidApi.preEncounter.patients.v1.search.Error
            >
        >
    > {
        const { mrn, similarNameOrdering } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (mrn != null) {
            _queryParams.mrn = mrn;
        }

        if (similarNameOrdering != null) {
            _queryParams.similar_name_ordering = similarNameOrdering;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                "/patients/v1",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.search.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.search.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Scans up to 1000 patient updates. The since query parameter is inclusive, and the result list is ordered by updatedAt ascending.
     *
     * **Polling Pattern:**
     * To continuously poll for updates without gaps:
     * 1. Make your initial request with a `since` timestamp (e.g., `since=2020-01-01T13:00:00.000Z`)
     * 2. The API returns 100 by default and up to 1000 patient records, sorted by `updated_at` ascending
     * 3. Find the `updated_at` value from the last record in the response
     * 4. Use that `updated_at` value as the `since` parameter in your next request
     * 5. Repeat steps 2-4 to ingest updates until you receive an empty list
     *
     * **Important Notes:**
     * - The `since` parameter is inclusive, so you may receive the last record from the previous batch again (you can deduplicate by ID and version)
     * - All patient records include `updated_at`, `id`, `version`, `deactivated`, and `updating_user` fields for tracking changes
     * - Timestamps have millisecond resolution for precise ordering
     *
     * @param {CandidApi.preEncounter.patients.v1.PatientScanRequest} request
     * @param {V1.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.preEncounter.patients.v1.scan({
     *         since: new Date("2024-01-15T09:30:00.000Z")
     *     })
     */
    public scan(
        request: CandidApi.preEncounter.patients.v1.PatientScanRequest,
        requestOptions?: V1.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.preEncounter.patients.v1.Patient[], CandidApi.preEncounter.patients.v1.scan.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__scan(request, requestOptions));
    }

    private async __scan(
        request: CandidApi.preEncounter.patients.v1.PatientScanRequest,
        requestOptions?: V1.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.preEncounter.patients.v1.Patient[],
                CandidApi.preEncounter.patients.v1.scan.Error
            >
        >
    > {
        const { since, maxResults } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.since = since.toISOString();
        if (maxResults != null) {
            _queryParams.maxResults = maxResults.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).preEncounter,
                "/patients/v1/updates/scan",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.preEncounter.patients.v1.scan.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.preEncounter.patients.v1.scan.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
