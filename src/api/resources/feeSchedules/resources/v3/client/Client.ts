/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import * as CandidApi from "../../../../../index";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers";
import * as serializers from "../../../../../../serialization/index";

export declare namespace V3 {
    export interface Options {
        environment?: core.Supplier<environments.CandidApiEnvironment | environments.CandidApiEnvironmentUrls>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }
}

export class V3 {
    protected readonly _options: V3.Options;

    constructor(_options: V3.Options = {}) {
        this._options = _options;
    }

    /**
     * Gets the rate that matches a service line.  No result means no rate exists matching the service line's dimensions.
     *
     * @param {CandidApi.ServiceLineId} serviceLineId
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.getMatch(CandidApi.ServiceLineId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"))
     */
    public getMatch(
        serviceLineId: CandidApi.ServiceLineId,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.feeSchedules.v3.MatchResult | undefined, CandidApi.feeSchedules.v3.getMatch.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__getMatch(serviceLineId, requestOptions));
    }

    private async __getMatch(
        serviceLineId: CandidApi.ServiceLineId,
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.feeSchedules.v3.MatchResult | undefined,
                CandidApi.feeSchedules.v3.getMatch.Error
            >
        >
    > {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                `/api/fee-schedules/v3/service-line/${encodeURIComponent(serializers.ServiceLineId.jsonOrThrow(serviceLineId))}/match`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.getMatch.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.feeSchedules.v3.getMatch.Error.Raw)?.errorName) {
                case "EntityNotFoundError":
                case "FailedToBuildServiceLineDimensions":
                    return {
                        data: {
                            ok: false,
                            error: serializers.feeSchedules.v3.getMatch.Error.parseOrThrow(
                                _response.error.body as serializers.feeSchedules.v3.getMatch.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.getMatch.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Tests a service line against a rate to see if it matches.
     *
     * @param {CandidApi.ServiceLineId} serviceLineId
     * @param {CandidApi.RateId} rateId
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.testMatch(CandidApi.ServiceLineId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"), CandidApi.RateId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"))
     */
    public testMatch(
        serviceLineId: CandidApi.ServiceLineId,
        rateId: CandidApi.RateId,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.feeSchedules.v3.MatchTestResult, CandidApi.feeSchedules.v3.testMatch.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__testMatch(serviceLineId, rateId, requestOptions));
    }

    private async __testMatch(
        serviceLineId: CandidApi.ServiceLineId,
        rateId: CandidApi.RateId,
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<CandidApi.feeSchedules.v3.MatchTestResult, CandidApi.feeSchedules.v3.testMatch.Error>
        >
    > {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                `/api/fee-schedules/v3/service-line/${encodeURIComponent(serializers.ServiceLineId.jsonOrThrow(serviceLineId))}/match/${encodeURIComponent(serializers.RateId.jsonOrThrow(rateId))}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.MatchTestResult.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.feeSchedules.v3.testMatch.Error.Raw)?.errorName) {
                case "EntityNotFoundError":
                case "FailedToBuildServiceLineDimensions":
                    return {
                        data: {
                            ok: false,
                            error: serializers.feeSchedules.v3.testMatch.Error.parseOrThrow(
                                _response.error.body as serializers.feeSchedules.v3.testMatch.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.testMatch.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Gets a list of dimensions with their rates. The rates returned will always be the most recent versions of those rates.
     *
     * @param {CandidApi.feeSchedules.v3.GetMultiRequest} request
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.getMulti()
     */
    public getMulti(
        request: CandidApi.feeSchedules.v3.GetMultiRequest = {},
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.feeSchedules.v3.RatesPage, CandidApi.feeSchedules.v3.getMulti.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__getMulti(request, requestOptions));
    }

    private async __getMulti(
        request: CandidApi.feeSchedules.v3.GetMultiRequest = {},
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<CandidApi.feeSchedules.v3.RatesPage, CandidApi.feeSchedules.v3.getMulti.Error>
        >
    > {
        const {
            pageToken,
            limit,
            activeDate,
            payerUuid,
            organizationBillingProviderId,
            states,
            zipCodes,
            licenseTypes,
            facilityTypeCodes,
            networkTypes,
            payerPlanGroupIds,
            cptCode,
            modifiers,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (pageToken != null) {
            _queryParams["page_token"] = pageToken;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (activeDate != null) {
            _queryParams["active_date"] = activeDate;
        }

        if (payerUuid != null) {
            _queryParams["payer_uuid"] = payerUuid;
        }

        if (organizationBillingProviderId != null) {
            _queryParams["organization_billing_provider_id"] = organizationBillingProviderId;
        }

        if (states != null) {
            if (Array.isArray(states)) {
                _queryParams["states"] = states.map((item) =>
                    serializers.State.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["states"] = serializers.State.jsonOrThrow(states, { unrecognizedObjectKeys: "strip" });
            }
        }

        if (zipCodes != null) {
            if (Array.isArray(zipCodes)) {
                _queryParams["zip_codes"] = zipCodes.map((item) => item);
            } else {
                _queryParams["zip_codes"] = zipCodes;
            }
        }

        if (licenseTypes != null) {
            if (Array.isArray(licenseTypes)) {
                _queryParams["license_types"] = licenseTypes.map((item) =>
                    serializers.organizationProviders.v2.LicenseType.jsonOrThrow(item, {
                        unrecognizedObjectKeys: "strip",
                    }),
                );
            } else {
                _queryParams["license_types"] = serializers.organizationProviders.v2.LicenseType.jsonOrThrow(
                    licenseTypes,
                    { unrecognizedObjectKeys: "strip" },
                );
            }
        }

        if (facilityTypeCodes != null) {
            if (Array.isArray(facilityTypeCodes)) {
                _queryParams["facility_type_codes"] = facilityTypeCodes.map((item) =>
                    serializers.FacilityTypeCode.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["facility_type_codes"] = serializers.FacilityTypeCode.jsonOrThrow(facilityTypeCodes, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        if (networkTypes != null) {
            if (Array.isArray(networkTypes)) {
                _queryParams["network_types"] = networkTypes.map((item) =>
                    serializers.NetworkType.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["network_types"] = serializers.NetworkType.jsonOrThrow(networkTypes, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        if (payerPlanGroupIds != null) {
            if (Array.isArray(payerPlanGroupIds)) {
                _queryParams["payer_plan_group_ids"] = payerPlanGroupIds.map((item) =>
                    serializers.PayerPlanGroupId.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["payer_plan_group_ids"] = payerPlanGroupIds;
            }
        }

        if (cptCode != null) {
            _queryParams["cpt_code"] = cptCode;
        }

        if (modifiers != null) {
            if (Array.isArray(modifiers)) {
                _queryParams["modifiers"] = modifiers.map((item) =>
                    serializers.ProcedureModifier.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["modifiers"] = serializers.ProcedureModifier.jsonOrThrow(modifiers, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                "/api/fee-schedules/v3",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.RatesPage.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.getMulti.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Gets unique values for a dimension based on other selection criteria. The response is a list of dimensions with your criteria and the unique values populated. This API is useful for driving pivots on dimension values.
     *
     * @param {CandidApi.feeSchedules.v3.GetUniqueDimensionValuesRequest} request
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.getUniqueValuesForDimension({
     *         pivotDimension: "payer_uuid"
     *     })
     */
    public getUniqueValuesForDimension(
        request: CandidApi.feeSchedules.v3.GetUniqueDimensionValuesRequest,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<
            CandidApi.feeSchedules.v3.DimensionsPage,
            CandidApi.feeSchedules.v3.getUniqueValuesForDimension.Error
        >
    > {
        return core.HttpResponsePromise.fromPromise(this.__getUniqueValuesForDimension(request, requestOptions));
    }

    private async __getUniqueValuesForDimension(
        request: CandidApi.feeSchedules.v3.GetUniqueDimensionValuesRequest,
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.feeSchedules.v3.DimensionsPage,
                CandidApi.feeSchedules.v3.getUniqueValuesForDimension.Error
            >
        >
    > {
        const {
            pageToken,
            limit,
            pivotDimension,
            payerUuid,
            organizationBillingProviderId,
            states,
            zipCodes,
            licenseTypes,
            facilityTypeCodes,
            networkTypes,
            payerPlanGroupIds,
            cptCode,
            modifiers,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (pageToken != null) {
            _queryParams["page_token"] = pageToken;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        _queryParams["pivot_dimension"] = serializers.feeSchedules.v3.DimensionName.jsonOrThrow(pivotDimension, {
            unrecognizedObjectKeys: "strip",
        });
        if (payerUuid != null) {
            _queryParams["payer_uuid"] = payerUuid;
        }

        if (organizationBillingProviderId != null) {
            _queryParams["organization_billing_provider_id"] = organizationBillingProviderId;
        }

        if (states != null) {
            if (Array.isArray(states)) {
                _queryParams["states"] = states.map((item) =>
                    serializers.State.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["states"] = serializers.State.jsonOrThrow(states, { unrecognizedObjectKeys: "strip" });
            }
        }

        if (zipCodes != null) {
            if (Array.isArray(zipCodes)) {
                _queryParams["zip_codes"] = zipCodes.map((item) => item);
            } else {
                _queryParams["zip_codes"] = zipCodes;
            }
        }

        if (licenseTypes != null) {
            if (Array.isArray(licenseTypes)) {
                _queryParams["license_types"] = licenseTypes.map((item) =>
                    serializers.organizationProviders.v2.LicenseType.jsonOrThrow(item, {
                        unrecognizedObjectKeys: "strip",
                    }),
                );
            } else {
                _queryParams["license_types"] = serializers.organizationProviders.v2.LicenseType.jsonOrThrow(
                    licenseTypes,
                    { unrecognizedObjectKeys: "strip" },
                );
            }
        }

        if (facilityTypeCodes != null) {
            if (Array.isArray(facilityTypeCodes)) {
                _queryParams["facility_type_codes"] = facilityTypeCodes.map((item) =>
                    serializers.FacilityTypeCode.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["facility_type_codes"] = serializers.FacilityTypeCode.jsonOrThrow(facilityTypeCodes, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        if (networkTypes != null) {
            if (Array.isArray(networkTypes)) {
                _queryParams["network_types"] = networkTypes.map((item) =>
                    serializers.NetworkType.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["network_types"] = serializers.NetworkType.jsonOrThrow(networkTypes, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        if (payerPlanGroupIds != null) {
            if (Array.isArray(payerPlanGroupIds)) {
                _queryParams["payer_plan_group_ids"] = payerPlanGroupIds.map((item) =>
                    serializers.PayerPlanGroupId.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["payer_plan_group_ids"] = payerPlanGroupIds;
            }
        }

        if (cptCode != null) {
            _queryParams["cpt_code"] = cptCode;
        }

        if (modifiers != null) {
            if (Array.isArray(modifiers)) {
                _queryParams["modifiers"] = modifiers.map((item) =>
                    serializers.ProcedureModifier.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
                );
            } else {
                _queryParams["modifiers"] = serializers.ProcedureModifier.jsonOrThrow(modifiers, {
                    unrecognizedObjectKeys: "strip",
                });
            }
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                "/api/fee-schedules/v3/unique-dimension-values",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.DimensionsPage.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.getUniqueValuesForDimension.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Gets every version of a rate.
     *
     * @param {CandidApi.RateId} rateId
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.getRateHistory(CandidApi.RateId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"))
     */
    public getRateHistory(
        rateId: CandidApi.RateId,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.feeSchedules.v3.Rate[], CandidApi.feeSchedules.v3.getRateHistory.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__getRateHistory(rateId, requestOptions));
    }

    private async __getRateHistory(
        rateId: CandidApi.RateId,
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<CandidApi.feeSchedules.v3.Rate[], CandidApi.feeSchedules.v3.getRateHistory.Error>
        >
    > {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                `/api/fee-schedules/v3/${encodeURIComponent(serializers.RateId.jsonOrThrow(rateId))}/history`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.getRateHistory.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.feeSchedules.v3.getRateHistory.Error.Raw)?.errorName) {
                case "EntityNotFoundError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.feeSchedules.v3.getRateHistory.Error.parseOrThrow(
                                _response.error.body as serializers.feeSchedules.v3.getRateHistory.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.getRateHistory.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Uploads a new fee schedule.\n Each rate may either be totally new as qualified by it's dimensions or a new version for an existing rate.\n If adding a new version to an existing rate, the rate must be posted with the next version number (previous version + 1) or a EntityConflictError will be returned.\n Use the dry run flag to discover already existing rates and to run validations.  If validations for any rate fail, no rates will be saved to the system.
     *
     * @param {CandidApi.feeSchedules.v3.FeeScheduleUploadRequest} request
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.uploadFeeSchedule({
     *         dryRun: true,
     *         rates: [{
     *                 type: "new_rate",
     *                 dimensions: {
     *                     payerUuid: CandidApi.payers.v3.PayerUuid("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"),
     *                     organizationBillingProviderId: CandidApi.organizationProviders.v2.OrganizationProviderId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"),
     *                     states: new Set(["AA"]),
     *                     zipCodes: new Set(["zip_codes"]),
     *                     licenseTypes: new Set(["MD"]),
     *                     facilityTypeCodes: new Set(["01"]),
     *                     networkTypes: new Set(["12"]),
     *                     payerPlanGroupIds: new Set([CandidApi.PayerPlanGroupId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32")]),
     *                     cptCode: "cpt_code",
     *                     modifiers: new Set(["AV"])
     *                 },
     *                 entries: [{
     *                         startDate: "2023-01-15",
     *                         rateCents: 1,
     *                         isDeactivated: true
     *                     }, {
     *                         startDate: "2023-01-15",
     *                         rateCents: 1,
     *                         isDeactivated: true
     *                     }]
     *             }, {
     *                 type: "new_rate",
     *                 dimensions: {
     *                     payerUuid: CandidApi.payers.v3.PayerUuid("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"),
     *                     organizationBillingProviderId: CandidApi.organizationProviders.v2.OrganizationProviderId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"),
     *                     states: new Set(["AA"]),
     *                     zipCodes: new Set(["zip_codes"]),
     *                     licenseTypes: new Set(["MD"]),
     *                     facilityTypeCodes: new Set(["01"]),
     *                     networkTypes: new Set(["12"]),
     *                     payerPlanGroupIds: new Set([CandidApi.PayerPlanGroupId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32")]),
     *                     cptCode: "cpt_code",
     *                     modifiers: new Set(["AV"])
     *                 },
     *                 entries: [{
     *                         startDate: "2023-01-15",
     *                         rateCents: 1,
     *                         isDeactivated: true
     *                     }, {
     *                         startDate: "2023-01-15",
     *                         rateCents: 1,
     *                         isDeactivated: true
     *                     }]
     *             }]
     *     })
     */
    public uploadFeeSchedule(
        request: CandidApi.feeSchedules.v3.FeeScheduleUploadRequest,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.feeSchedules.v3.Rate[], CandidApi.feeSchedules.v3.uploadFeeSchedule.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__uploadFeeSchedule(request, requestOptions));
    }

    private async __uploadFeeSchedule(
        request: CandidApi.feeSchedules.v3.FeeScheduleUploadRequest,
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<CandidApi.feeSchedules.v3.Rate[], CandidApi.feeSchedules.v3.uploadFeeSchedule.Error>
        >
    > {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                "/api/fee-schedules/v3",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.feeSchedules.v3.FeeScheduleUploadRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.uploadFeeSchedule.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.feeSchedules.v3.uploadFeeSchedule.Error.Raw)?.errorName) {
                case "FeeScheduleValidationHttpError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.feeSchedules.v3.uploadFeeSchedule.Error.parseOrThrow(
                                _response.error.body as serializers.feeSchedules.v3.uploadFeeSchedule.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.uploadFeeSchedule.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Soft deletes a rate from the system.  Only the most recent version of a rate can be deleted.
     *
     * @param {CandidApi.RateId} rateId
     * @param {number} version
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.deleteRate(CandidApi.RateId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"), 1)
     */
    public deleteRate(
        rateId: CandidApi.RateId,
        version: number,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<void, CandidApi.feeSchedules.v3.deleteRate.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__deleteRate(rateId, version, requestOptions));
    }

    private async __deleteRate(
        rateId: CandidApi.RateId,
        version: number,
        requestOptions?: V3.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<void, CandidApi.feeSchedules.v3.deleteRate.Error>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                `/api/fee-schedules/v3/${encodeURIComponent(serializers.RateId.jsonOrThrow(rateId))}/${encodeURIComponent(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: undefined,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.feeSchedules.v3.deleteRate.Error.Raw)?.errorName) {
                case "EntityNotFoundError":
                case "EntityConflictError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.feeSchedules.v3.deleteRate.Error.parseOrThrow(
                                _response.error.body as serializers.feeSchedules.v3.deleteRate.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.deleteRate.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Gets the default payer threshold
     *
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.getPayerThresholdsDefault()
     */
    public getPayerThresholdsDefault(
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<
            CandidApi.feeSchedules.v3.PayerThreshold,
            CandidApi.feeSchedules.v3.getPayerThresholdsDefault.Error
        >
    > {
        return core.HttpResponsePromise.fromPromise(this.__getPayerThresholdsDefault(requestOptions));
    }

    private async __getPayerThresholdsDefault(
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.feeSchedules.v3.PayerThreshold,
                CandidApi.feeSchedules.v3.getPayerThresholdsDefault.Error
            >
        >
    > {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                "/api/fee-schedules/v3/payer-threshold/default",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.PayerThreshold.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.getPayerThresholdsDefault.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Gets a list of payers and thresholds by their uuids
     *
     * @param {CandidApi.feeSchedules.v3.PayerThresholdGetRequest} request
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.getPayerThresholds({
     *         payerUuids: CandidApi.payers.v3.PayerUuid("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32")
     *     })
     */
    public getPayerThresholds(
        request: CandidApi.feeSchedules.v3.PayerThresholdGetRequest,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<
            CandidApi.feeSchedules.v3.PayerThresholdsPage,
            CandidApi.feeSchedules.v3.getPayerThresholds.Error
        >
    > {
        return core.HttpResponsePromise.fromPromise(this.__getPayerThresholds(request, requestOptions));
    }

    private async __getPayerThresholds(
        request: CandidApi.feeSchedules.v3.PayerThresholdGetRequest,
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.feeSchedules.v3.PayerThresholdsPage,
                CandidApi.feeSchedules.v3.getPayerThresholds.Error
            >
        >
    > {
        const { payerUuids } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (Array.isArray(payerUuids)) {
            _queryParams["payer_uuids"] = payerUuids.map((item) =>
                serializers.payers.v3.PayerUuid.jsonOrThrow(item, { unrecognizedObjectKeys: "strip" }),
            );
        } else {
            _queryParams["payer_uuids"] = payerUuids;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                "/api/fee-schedules/v3/payer-threshold",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.PayerThresholdsPage.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.getPayerThresholds.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Sets the threshold information for a payer
     *
     * @param {CandidApi.payers.v3.PayerUuid} payerUuid
     * @param {CandidApi.feeSchedules.v3.PayerThreshold} request
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.setPayerThreshold(CandidApi.payers.v3.PayerUuid("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"), {
     *         disablePaidIncorrectly: true
     *     })
     */
    public setPayerThreshold(
        payerUuid: CandidApi.payers.v3.PayerUuid,
        request: CandidApi.feeSchedules.v3.PayerThreshold,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<
        core.APIResponse<CandidApi.feeSchedules.v3.PayerThreshold, CandidApi.feeSchedules.v3.setPayerThreshold.Error>
    > {
        return core.HttpResponsePromise.fromPromise(this.__setPayerThreshold(payerUuid, request, requestOptions));
    }

    private async __setPayerThreshold(
        payerUuid: CandidApi.payers.v3.PayerUuid,
        request: CandidApi.feeSchedules.v3.PayerThreshold,
        requestOptions?: V3.RequestOptions,
    ): Promise<
        core.WithRawResponse<
            core.APIResponse<
                CandidApi.feeSchedules.v3.PayerThreshold,
                CandidApi.feeSchedules.v3.setPayerThreshold.Error
            >
        >
    > {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                `/api/fee-schedules/v3/payer-threshold/${encodeURIComponent(serializers.payers.v3.PayerUuid.jsonOrThrow(payerUuid))}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.feeSchedules.v3.PayerThreshold.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.PayerThreshold.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch ((_response.error.body as serializers.feeSchedules.v3.setPayerThreshold.Error.Raw)?.errorName) {
                case "EntityNotFoundError":
                    return {
                        data: {
                            ok: false,
                            error: serializers.feeSchedules.v3.setPayerThreshold.Error.parseOrThrow(
                                _response.error.body as serializers.feeSchedules.v3.setPayerThreshold.Error.Raw,
                                {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    breadcrumbsPrefix: ["response"],
                                },
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.setPayerThreshold.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Hard deletes rates from the system that match the provided dimensions.  This is a destructive operation and cannot be undone.  If an empty dimensions object is provided, all rates will be hard deleted.  The maximum number of rates this API will delete at a time is 10000.  Returns the number of rates deleted and if that number is the maximum, the caller should call this API again to continue deleting rates.
     *
     * @param {CandidApi.feeSchedules.v3.OptionalDimensions} request
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.hardDeleteRates({
     *         states: new Set(["AA"]),
     *         zipCodes: new Set(["zip_codes"]),
     *         licenseTypes: new Set(["MD"]),
     *         facilityTypeCodes: new Set(["01"]),
     *         networkTypes: new Set(["12"]),
     *         payerPlanGroupIds: new Set([CandidApi.PayerPlanGroupId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32")]),
     *         modifiers: new Set(["AV"])
     *     })
     */
    public hardDeleteRates(
        request: CandidApi.feeSchedules.v3.OptionalDimensions,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<number, CandidApi.feeSchedules.v3.hardDeleteRates.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__hardDeleteRates(request, requestOptions));
    }

    private async __hardDeleteRates(
        request: CandidApi.feeSchedules.v3.OptionalDimensions,
        requestOptions?: V3.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<number, CandidApi.feeSchedules.v3.hardDeleteRates.Error>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                "/api/fee-schedules/v3/hard-delete",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.feeSchedules.v3.OptionalDimensions.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.hardDeleteRates.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.hardDeleteRates.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Hard deletes specific rates from the system by their IDs. This is a destructive operation and cannot be undone. Limited to 100 rate IDs maximum per request. For bulk deletion of more than 100 rates, use the hard_delete_rates endpoint with dimension filters. Returns the number of rates deleted.
     *
     * @param {CandidApi.feeSchedules.v3.HardDeleteRatesByIdsRequest} request
     * @param {V3.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feeSchedules.v3.hardDeleteRatesByIds({
     *         rateIds: [CandidApi.RateId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32"), CandidApi.RateId("d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32")]
     *     })
     */
    public hardDeleteRatesByIds(
        request: CandidApi.feeSchedules.v3.HardDeleteRatesByIdsRequest,
        requestOptions?: V3.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<number, CandidApi.feeSchedules.v3.hardDeleteRatesByIds.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__hardDeleteRatesByIds(request, requestOptions));
    }

    private async __hardDeleteRatesByIds(
        request: CandidApi.feeSchedules.v3.HardDeleteRatesByIdsRequest,
        requestOptions?: V3.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<number, CandidApi.feeSchedules.v3.hardDeleteRatesByIds.Error>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (
                        (await core.Supplier.get(this._options.environment)) ??
                        environments.CandidApiEnvironment.Production
                    ).candidApi,
                "/api/fee-schedules/v3/hard-delete-by-ids",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.feeSchedules.v3.HardDeleteRatesByIdsRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: serializers.feeSchedules.v3.hardDeleteRatesByIds.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: CandidApi.feeSchedules.v3.hardDeleteRatesByIds.Error._unknown(_response.error),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
