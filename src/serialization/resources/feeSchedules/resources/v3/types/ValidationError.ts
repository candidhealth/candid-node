// This file was auto-generated by Fern from our API Definition.

import type * as CandidApi from "../../../../../../api/index";
import * as core from "../../../../../../core";
import type * as serializers from "../../../../../index";
import { EntityConflictErrorMessage } from "../../../../commons/types/EntityConflictErrorMessage";
import { EntityNotFoundErrorMessage } from "../../../../commons/types/EntityNotFoundErrorMessage";
import { OverlappingRateEntriesError } from "./OverlappingRateEntriesError";
import { PayerPlanGroupDoesNotMatchRatePayerError } from "./PayerPlanGroupDoesNotMatchRatePayerError";

export const ValidationError: core.serialization.Schema<
    serializers.feeSchedules.v3.ValidationError.Raw,
    CandidApi.feeSchedules.v3.ValidationError
> = core.serialization
    .union("type", {
        overlapping_rate_entries: OverlappingRateEntriesError,
        version_conflict: EntityConflictErrorMessage,
        organization_provider_not_found: EntityNotFoundErrorMessage,
        duplicate_rate: core.serialization.object({}),
        empty_entries: core.serialization.object({}),
        payer_plan_group_not_found: EntityNotFoundErrorMessage,
        payer_plan_group_does_not_match_rate_payer: PayerPlanGroupDoesNotMatchRatePayerError,
        payer_plan_group_network_type_mutual_exclusion: EntityConflictErrorMessage,
    })
    .transform<CandidApi.feeSchedules.v3.ValidationError>({
        transform: (value) => value,
        untransform: (value) => value,
    });

export declare namespace ValidationError {
    export type Raw =
        | ValidationError.OverlappingRateEntries
        | ValidationError.VersionConflict
        | ValidationError.OrganizationProviderNotFound
        | ValidationError.DuplicateRate
        | ValidationError.EmptyEntries
        | ValidationError.PayerPlanGroupNotFound
        | ValidationError.PayerPlanGroupDoesNotMatchRatePayer
        | ValidationError.PayerPlanGroupNetworkTypeMutualExclusion;

    export interface OverlappingRateEntries extends OverlappingRateEntriesError.Raw {
        type: "overlapping_rate_entries";
    }

    export interface VersionConflict extends EntityConflictErrorMessage.Raw {
        type: "version_conflict";
    }

    export interface OrganizationProviderNotFound extends EntityNotFoundErrorMessage.Raw {
        type: "organization_provider_not_found";
    }

    export interface DuplicateRate {
        type: "duplicate_rate";
    }

    export interface EmptyEntries {
        type: "empty_entries";
    }

    export interface PayerPlanGroupNotFound extends EntityNotFoundErrorMessage.Raw {
        type: "payer_plan_group_not_found";
    }

    export interface PayerPlanGroupDoesNotMatchRatePayer extends PayerPlanGroupDoesNotMatchRatePayerError.Raw {
        type: "payer_plan_group_does_not_match_rate_payer";
    }

    export interface PayerPlanGroupNetworkTypeMutualExclusion extends EntityConflictErrorMessage.Raw {
        type: "payer_plan_group_network_type_mutual_exclusion";
    }
}
